/*
 * generate_delay.c
 *
 * Created: 10-05-2018 16:33:19
 *  Author: Bhushan
 */ 

#define F_CPU 1000000
#include<avr/io.h>
#include<util/delay.h>
#include<avr/interrupt.h>
#include "Timer_Counter_header.h"
//void generate_square_normal(unsigned int,unsigned char,unsigned char,unsigned char);
unsigned int temp,tempreg;
unsigned char porti,pini;
unsigned int* ptr;
unsigned int frequency=0;    //frequency of the incoming square wave on the ICP1 pin 
unsigned char count;
//If you want variable duty cycle then please go for CTC mode rather than Normal mode
int main(void)
{
	//Run the functions one after the other , they may use the same variables/memory space 
	sei();
	//temp=generate_square_normal(20,50,'A',5);   // Here first pass the time_period , then the Duty Cycle , 50% for normal mode , The port and the Pin as output 
	porti='A';                                  //here the required time period is being generated by the TIMER1 in normal mode to be specified in milli-seconds  
	pini=5;
	//DDRB|=(1<<PB0);   //also used for the fast pwm mode generating waves 
	//DDRD&=~(1<<PD6);  //configure the ICP1 pin as input 
	//DDRA=0xFF;        //the frequency of the ICP1 pin wave is displayed on this PORT 
	//ptr=generate_square_ctc(100,30);             //time_period in ms and duty cycle in percentage 
	/*read frequency from input capture pin on the controller*/
	//read_frequency();  //read the frequency on the ICP1 pin , frequency being stored in the frequency variable 
	//frequency upto 255 Hz were read upto good accuracy 
	ptr=generate_square_fast_pwm(100,30,'B',0);      //generate the fast pwm on a given PORT pin , time period in miliseconds and duty cycle in percentage
	while(1)
    {
        //TODO:: Please write your application code 
    }
}

//This is the ISR for the CTC mode timer_1
ISR(TIMER1_COMPA_vect)
{
	//unsigned int temporary;
	
	cli();
	//DDRA=0xFF;                //just in case to display the data 
	//ISR for the OCR1A output compare mode (CTC in toggle mode)
	if(PORTB&(1<<PB0))
	{
		PORTB^=(1<<PB0);
		//temporary=floor(0.976*(*ptr)*(*(ptr+1))/100);
		//OCR1AH=int(floor(0.976*(*ptr)*(*(ptr+1))/100))>>8; //for the high part of the wave : and the duty cycle in percentage and time_period in milliseconds
		//OCR1AL=int(floor(0.976*(*ptr)*(*(ptr+1))/100))&0xFF;
		//high on the OC1A pin , so time period equals DT , else time period equals (1-D)T
		OCR1A=floor(0.976*(*(ptr))*(100-(*(ptr+1)))/100);
		//ptr=ptr-1;
		//PORTA=(*(ptr));                    //Display the time_period on PORTA if needed
		
		
	}
	else
	{
		PORTB^=(1<<PB0);
		//OCR1AH=int(floor(0.976*(100-*(ptr))*(*(ptr+1))/100))>>8; //for the high part of the wave : and the duty cycle in percentage and time_period in milliseconds
		//OCR1AL=int(floor(0.976*(100-*(ptr))*(*(ptr+1))/100))&0xFF;
		//low on the OC1A pin , so time period is (1-D)T , else it is DT 
	    OCR1A=floor(0.976*(*(ptr))*((*(ptr+1)))/100);
		///ptr=ptr-1;
		//PORTA=(*(ptr+1));                  //Display the duty cycle on PORTA if needed
		
	}
	sei();
}


//This is the ISR for the generate_normal_using_timer_1
ISR(TIMER1_OVF_vect)
{
	cli();
	//the timer has successfully overflown
	//toggle the Pin
	//TCNT1=temp;
	TCNT1=temp;
	if(porti=='A')
	{
		PORTA^=(1<<pini);
	}
	else if(porti=='B')
	{
		PORTB^=(1<<pini);
	}
	else if(porti=='C')
	{
		PORTC^=(1<<pini);
	}
	else if(porti=='D')
	{
		PORTD^=(1<<pini);
	}
	sei();
}


//This is the ISR for the input capture mode
ISR(TIMER1_CAPT_vect)
{
	cli();
	//runs this ISR whenever an input capture occurs on the ICP1 pin 
	//The Input Capture is updated with the counter (TCNT1) value each time an event occurs on the ICP1 pin
	//(or optionally on the Analog Comparator output for Timer/Counter1). The Input Capture can be used for
	//defining the counter TOP value.
	//ICR1=TCNT1;
	//PORTB^=(1<<PB0);             //toggle the bits of the portb bit 0 so as to notice something 
	if(count>=100)
	{
		//enough pulses are done , so calculate the difference of the TCNT values , disable the timer from further use
		frequency=floor(976.5625/(ICR1-tempreg));//the frequency is found out 
		TIMSK&=~(1<<TICIE1); //disable the interrupts for further use 
		//SPDR=(ICR1-tempreg)>>8;
		frequency+=1;
		PORTA=frequency&(0xFF);   //display the frequency on the PORTA     
		//UDR=ICR1>>8;
	}
	else
	{
		tempreg=ICR1;          // read the ICR1 into tempreg 
		count++;
	}
	
	sei();
}


//This is the ISR of the fast_pwm mode for generating variable duty cycle and frequency
ISR(TIMER1_OVF_vect)
{
	//Here PB0 is taken as the digital pin 
	cli();
	//This is for the fast pwm mode generating waves using the OCR register for storing the high value
	//If the current state of the pin is LOW initialize to DT else initialize it to (1-D)T
	if(PORTB&(1<<PB0))            //that pin being high 
	{
		//set ocr1a and then toggle the pin
		PORTB&=~(1<<PB0);//toggle
		OCR1A=floor((0.9765625)*(*(ptr))*(100-(*(ptr+1)))/100);
		//OCR1A=floor((0.9765625)*(100-duty_cycle)*(time_period)/100); 
		//OCR1A=30;
	}
	else
	{
		PORTB|=(1<<PB0);//toggle
		OCR1A=floor((0.9765625)*(*(ptr))*(*(ptr+1))/100);
		//OCR1A=floor((0.9765625)*(duty_cycle)*(time_period)/100); 
		//OCR1A=30;
	}
	sei();
}